{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 homework notes W2D3\
\
Big O analysis\
lecture outline:\
motivations\
RAM model of computation\
Asymptotatic Analysis\
The worst case\
Big O Classifications\
Set definition\
Space and time\
\
Motivations:\
is Algorithm A better than Algorithm B? how fast does it run.\
what factors determine the speed of the algorithm? hardware, language implementation, input size, the number of steps. Algorithm is not necessarily dependent on hardware or language implementation others are determined directly by Algorithm.\
\
RAM model of computation\
what are number of steps? what constitutes a step? + is one step. - is 1.2 step. * is 1.3 step. / is 1.8 step. <,> is 1 step. <=, => is 2 step. === is 1 step. this is ridiculous. We use models of computation. Random Access Machine. all operators are 1 step. loop is number of times multiplied by each operator in iteration. Memory Access and function calls are 1 step. \
\
Asymptotic Analysis\
chop add and iter add, both add two numbers. \
chop add steps: 3 + 3 + 300(3+3) + 4 + 300(3) + 10 +1800 + 900 = 2710 steps\
tier add steps: 3n + 1\
desmos.com/calculator\
if input size is less than 1000 iter add is faster. otherwise chop add is faster.\
asymptotic analysis: tool to come up with run time. behavior of a line as it approaches its limit. how it behaves as it reaches infinite. consider most dominant term. ignore all constants. if only constant just 1. Most dominant term only as fast as your bottleneck\
\
The Worst Case\
\
Definition\
Big O is asymptotic worst case run time. don\'92t consider best case as it is ideal. \
\
Common classifications\
O(1) - Constant. runtime is independent of input size\
O(log n) - Logarithmic. if at every step the input size is being divided\
O(n) - Linear\
O(n log n) - Log Linear. merge sort. quick sort (best avg)\
O(n^2) - quadratic. bubble sort (worst case). nested loops x2\
O(n^k) - polynomial functions k > 2\
O(2^n) - exponential, subsets\
O(n!) - permutations/factorial\
\
Set Definition of big O\
O(n^2) = function\
n does not dominate n^2\
big O notation is a relative representation of the complexity of an algorithm. can only compare apples to apples. Big O reduces the comparison between algorithms to a single variable. \
\
Space and Time\
example: function takes in two arrays \
XOR. If you XOR the same number twice it will cancel out. all numbers have byte definitions. \
}